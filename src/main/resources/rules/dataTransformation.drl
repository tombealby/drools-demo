package rules;

import java.util.*;
import java.math.BigDecimal;

import com.example.demo.service.LegacyBankService;
import com.example.demo.report.ValidationReportImpl;
import com.example.demo.report.ReportFactoryImpl;
import com.example.demo.model.Address;
import com.example.demo.model.Country;
import com.example.demo.report.Message;
import com.example.demo.service.CurrencyConverterUtils;

global ValidationReportImpl validationReport;
global ReportFactoryImpl reportFactory;
global LegacyBankService legacyService;

//global ValidationReport validationReport;
//global ReportFactory reportFactory;
//global LegacyBankService legacyService;

rule findAllCustomers
dialect "mvel"
when
	$customerMap : Map( )
		from legacyService.findAllCustomers()
then
	$customerMap["_type_"] = "Customer"
		insert( $customerMap )
		System.out.println ("findAllCustomers consequence inserted  " + $customerMap);
end
rule findAddress
dialect "mvel"
   when
      $customerMap : Map( this["_type_"] == "Customer" )
       $addressMap : Map( )
         from legacyService.findAddressByCustomerId(
            $customerMap["customer_id"] )
   then

      $addressMap["_type_"] = "Address"
       insert( $addressMap )
       System.out.println ("findAddress consequence inserted  " + $addressMap);
end
rule twoEqualAddressesDifferentInstance
when

	$addressMap1 : Map( this["_type_"] == "Address" )

	$addressMap2 : Map( this["_type_"] == "Address")

	eval( $addressMap1 != $addressMap2 )

//	$addressMap2 : Map( this["_type_"] == "Address",
//		eval( $addressMap1 != $addressMap2 ),
//			this == $addressMap1 )
then
	retract( $addressMap2 );
	validationReport.addMessage(
		reportFactory.createMessage(Message.Type.WARNING,
		kcontext.getRule().getName(), $addressMap2));
		System.out.println ("twoEqualAddressesDifferentInstance consequence retracting" + $addressMap2);
end
rule addressNormalizationUSA
when
	$addressMap : Map( this["_type_"] == "Address",
	this["country"] in ("US", "U.S.", "USA", "U.S.A"))
then
    System.out.println ("addressNormalizationUSA consequence");
	modify( $addressMap ) {
		put("country", Country.USA)
	}
end
rule unknownCountry
salience -10 //should fire after address normalizations
when
	$addressMap : Map( this["_type_"] == "Address",
		eval(!($addressMap.get("country") instanceof
		Country)))
then
	System.out.println ("unknownCountry consequence");
	validationReport.addMessage(
		reportFactory.createMessage(Message.Type.ERROR,
		kcontext.getRule().getName(), $addressMap));
end
rule currencyConversionToEUR
dialect "mvel"
when
	$accountMap : Map( this["_type_"] == "Account",
		this["currency"] != null && != "EUR" )
		$conversionAmount : String() from
		CurrencyConverterUtils.getConversionToEurFrom($accountMap["currency"])
then
	modify($accountMap) {
		put("currency", "EUR"),
		put("balance", new BigDecimal(
			$conversionAmount).multiply(new BigDecimal(
			(String)$accountMap.get("balance"))))
	}
end
rule unknownCurrency
when
	$accountMap : Map( this["_type_"] == "Account",
		this["currency"] != null && != "EUR" )
		not( String() from 
		CurrencyConverterUtils.getConversionToEurFrom($accountMap["currency"]) )
then
	validationReport.addMessage(
		reportFactory.createMessage(Message.Type.ERROR,
		kcontext.getRule().getName(), $accountMap));
end
rule reduceLegacyAccounts
when
	$accountMap1 : Map( this["_type_"] == "Account" )
	$accountMap2 : Map( this["_type_"] == "Account",
		eval( $accountMap1 != $accountMap2 ),
		this["customer_id"] ==$accountMap1["customer_id"],
		this["currency"] == $accountMap1["currency"])
then
	modify($accountMap1) {
		put("balance", (
		(BigDecimal)$accountMap1.get("balance")).add(
		(BigDecimal)$accountMap2.get("balance")))
	}
	retract( $accountMap2 );
end
